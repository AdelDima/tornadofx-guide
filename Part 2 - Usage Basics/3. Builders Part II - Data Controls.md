#Builders Part II - Data Controls

Any significant application works with data, and providing a means for users to view, manipulate, and modify data is not a trivial task for user interface development. Fortunately, TornadoFX streamlines many JavaFX data controls such as `ListView`, `TableView`, and `TreeView`. These controls can be cumbersome to set up in a purely object-oriented way. But using builders through functional declarations, we can code all these controls in a much more declarative way. 

###ListView
A `ListView` is similar to a `ComboBox` but it displays all items (within a `ScrollView` if there are many) and has the option of allowing multiple selections.

```kotlin
listview<String> {
    items.add("Alpha")
    items.add("Beta")
    items.add("Gamma")
    items.add("Delta")
    items.add("Epsilon")
    selectionModel.selectionMode = SelectionMode.MULTIPLE
}
```

**RENDERED UI:**

![](http://i.imgur.com/D78DGbD.png)

You can also provide it an `ObservableList` of items up front and omit the type declaration.

```kotlin
val greekLetters = FXCollections.observableArrayList("Alpha","Beta",
        "Gamma","Delta","Epsilon")

listview(greekLetters) {
    selectionModel.selectionMode = SelectionMode.MULTIPLE
}
```

Like most data controls, keep in mind that by default, the `ListView` will call `toString()` to render the text for each item in your domain class.  

###TableView

Probably one of the most significant builders in TornadoFX is the one for `TableView`. If you have worked with JavaFX, you might have experienced building a `TableView` in an object-oriented way. But TornadoFX provides a functional declaration construct pattern using extension functions that greatly simplifies building a `TableView`. 

Say you have a domain type, such as `Person`. 

```kotlin
class Person(val id: Int, val name: String, val birthday: LocalDate) {
    val age: Int get() = Period.between(birthday, LocalDate.now()).years
}
```

Take several instances of `Person` and put them in an `ObservableList`. 

```kotlin
private val persons = FXCollections.observableArrayList<Person>(
        Person(1,"Samantha Stuart",LocalDate.of(1981,12,4)),
        Person(2,"Tom Marks",LocalDate.of(2001,1,23)),
        Person(3,"Stuart Gills",LocalDate.of(1989,5,23)),
        Person(3,"Nicole Williams",LocalDate.of(1998,8,11))
)
```

You can quickly declare a `TableView` with all of its columns using a functional construct, and specify the `items` property to an `ObservableList<Person>`.

```kotlin
tableview<Person> {
    items = persons
    column("ID",Person::id)
    column("Name", Person::name)
    column("Birthday", Person::birthday)
    column("Age",Person::age)
}
```

**RENDERED UI:**

![](https://camo.githubusercontent.com/21d91e000f36556b67bea322ff1152199aee483e/68747470733a2f2f692e696d6775722e636f6d2f41474d435038532e706e67)

The `column()` functions are extension functions for `TableView` accepting a `title` and a mapped property using a reflection syntax. 

####Using "Property" properties

If you follow the JavaFX `Property` conventions to set up your domain class, it will automatically support value editing. 

You can create these `Property` objects the conventional way, or you can use TornadoFX's `property` delegates to automatically create these `Property` declarations as shown above. 

```kotlin
class Person(id: Int, name: String, birthday: LocalDate) {
    var id by property<Int>()
    fun idProperty() = getProperty(Person::id)

    var name by property<String>()
    fun nameProperty() = getProperty(Person::name)

    var birthday by property<LocalDate>()
    fun birthdayProperty() = getProperty(Person::birthday)

    val age: Int get() = Period.between(birthday, LocalDate.now()).years

    init {
        this.id = id
        this.name = name
        this.birthday = birthday
    }
}
```

You need to create `xxxProperty()` functions for each property to support JavaFX's convention when it uses reflection. This can easily be done by relaying their calls to `getProperty()` to retrieve the `Property` for a given field. See Chapter X for more information on these property delegates. 

####Using cellFormat()

There are other extension functions applied to `TableView` that can assist the flow of declaring a `TableView`. For instance, you can call a `cellFormat()` function on a given column to apply formatting rules, such as highlighting "Age" values less than 18. 

```kotlin
tableview<Person> {
    items = persons
    column("ID",Person::id)
    column("Name", Person::name)
    column("Birthday", Person::birthday)
    column("Age",Person::age).cellFormat {
        if (it < 18) {
            style = "-fx-background-color:#8b0000; -fx-text-fill:white"
            text = it.toString()
        } else {
            text = it.toString()
        }
     }
}
```

**RENDERED UI:**

![](https://camo.githubusercontent.com/dbc9a172be484e4ab8eeb0accc3799500e9fe791/68747470733a2f2f692e696d6775722e636f6d2f4d7932475545762e706e67)


####Declaring Column Values Functionally

If you need to map a column's value to a non-property (such as a function), you can use a non-reflection means to extract the values for that column.

Say you have a `WeeklyReport` type that has a `getTotal()` function accepting a `DayOfWeek` argument (an enum of Monday, Tuesday... Sunday).

```kotlin 
abstract class WeeklyReport(val startDate: LocalDate) {
    abstract fun getTotal(dayOfWeek: DayOfWeek): BigDecimal
}
```

Let's say you wanted to create a column for each `DayOfWeek`. You cannot map to properties, but you can map each `WeeklyReport` item explicitly to extract each value for that `DayOfWeek`. 

```kotlin
tableview<WeeklyReport> {
    for (dayOfWeek in DayOfWeek.values()) {
        column<WeeklyReport, BigDecimal>(dayOfWeek.toString()) {
            ReadOnlyObjectWrapper(it.value.getTotal(dayOfWeek))
        }
    }
}
```
This more closely resembles the traditional `setCellValueFactory()` for the `TableColumn` type. 

###TreeView

###TreeTableView