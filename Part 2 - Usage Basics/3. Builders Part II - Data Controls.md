#Builders Part II - Data Controls

Any significant application works with data, and providing a means for users to view, manipulate, and modify data is not a trivial task for user interface development. Fortunately, TornadoFX streamlines many JavaFX data controls such as `ListView`, `TableView`, and `TreeView`. These controls can be cumbersome to set up in a purely object-oriented way. But using builders through functional declarations, we can code all these controls in a much more declarative way. 

###ListView
A `ListView` is similar to a `ComboBox` but it displays all items (within a `ScrollView` if there are many) and has the option of allowing multiple selections.

```kotlin
listview<String> {
    items.add("Alpha")
    items.add("Beta")
    items.add("Gamma")
    items.add("Delta")
    items.add("Epsilon")
    selectionModel.selectionMode = SelectionMode.MULTIPLE
}
```

**RENDERED UI:**

![](http://i.imgur.com/D78DGbD.png)

You can also provide it an `ObservableList` of items up front and omit the type declaration.

```kotlin
val greekLetters = FXCollections.observableArrayList("Alpha","Beta",
        "Gamma","Delta","Epsilon")

listview(greekLetters) {
    selectionModel.selectionMode = SelectionMode.MULTIPLE
}
```

Like most data controls, keep in mind that by default, the `ListView` will call `toString()` to render the text for each item in your domain class.  

###TableView

Probably one of the most significant builders in TornadoFX is the one for `TableView`. If you have worked with JavaFX, you might have experienced building a `TableView` in an object-oriented way. But TornadoFX provides a functional declaration construct pattern using extension functions that greatly simplifies building a `TableView`. 

Say you have a domain type, such as `Person`. 

```kotlin
class Person(val id: Int, val name: String, val birthday: LocalDate) {
    val age: Int get() = Period.between(birthday, LocalDate.now()).years
}
```

Take several instances of `Person` and put them in an `ObservableList`. 

```kotlin
private val persons = FXCollections.observableArrayList<Person>(
        Person(1,"Samantha Stuart",LocalDate.of(1981,12,4)),
        Person(2,"Tom Marks",LocalDate.of(2001,1,23)),
        Person(3,"Stuart Gills",LocalDate.of(1989,5,23)),
        Person(3,"Nicole Williams",LocalDate.of(1998,8,11))
)
```

You can quickly declare a `TableView` with all of its columns using a functional construct, and specify the `items` property to an `ObservableList<Person>`.

```kotlin
tableview<Person> {
    items = persons
    column("ID",Person::id)
    column("Name", Person::name)
    column("Birthday", Person::birthday)
    column("Age",Person::age)
}
```

**RENDERED UI:**
![](https://camo.githubusercontent.com/21d91e000f36556b67bea322ff1152199aee483e/68747470733a2f2f692e696d6775722e636f6d2f41474d435038532e706e67)

The `column()` functions are extension functions for `TableView` accepting a `title` and a mapped property using a reflection syntax. 

If you follow the JavaFX `Property` conventions to set up your class, you can even support value editing. 

```kotlin
class Person(id: Int, name: String, birthday: LocalDate) {
    var id by property<Int>()
    fun idProperty() = getProperty(Person::id)

    var name by property<String>()
    fun nameProperty() = getProperty(Person::name)

    var birthday by property<LocalDate>()
    fun birthdayProperty() = getProperty(Person::birthday)

    val age: Int get() = Period.between(birthday, LocalDate.now()).years

    init {
        this.id = id
        this.name = name
        this.birthday = birthday
    }
}
```

You can create these `Property` objects the conventional way, or you can use TornadoFX delegates to automatically create these `Property` declarations as shown above. See Chapter X for more information on these property delegates. 

###TreeView

###TreeTableView