# FXML based user interfaces

TornadoFX's type-safe builders provide a fast, easy, and declarative way to construct UI's. This DSL approach is encouraged because it is more flexible, simpler, and more reliable. However, JavaFX also supports an XML-based structure called FXML that can build a UI layout too. TornadoFX has tools to streamline FXML usage for those that need it. 

If you are unfamiliar with FXML and are perfectly happy with type-safe builders, please feel free to skip this chapter. If you need to work with FXML or feel you should learn it, please read on. You can also take a look at the [official FXML documentation](https://docs.oracle.com/javase/8/javafx/fxml-tutorial/why_use_fxml.htm) if you are not familiar with it. 

## Reasons for Considering FXML

While the developers of TornadoFX strongly encourage using type-safe builders, there are situations and factors that might cause you to consider using FXML. 

### Separation of concerns
With FXML it is easy to separate your UI logic code from the code that constructs the UI. This separation is just as achievable with type-safe builders by utilizing MVP or some other separation pattern. But some programmers find FXML forces them to maintain this separation and prefer it for that reason.

### WYSIWYG Editor

FXML files also can be edited and processed by [Scene Builder](http://www.oracle.com/technetwork/java/javase/downloads/javafxscenebuilder-info-2157684.html), a visual layout tool that allows building interfaces via drag-and-drop functionality. Edits in Scene Builder are immediately rendered in a WYSIWYG ("What You See is What You Get") pane next to the editor.

If you prefer making interfaces via drag-and-drop, or have trouble building UI's with pure code, you might consider using FXML just to leverage Scene Builder.

### Compatibility with Existing Codebases

If you are converting an existing JavaFX application to TornadoFX, there is a strong chance your UI was constructed with FXML. If you hesitate to transition legacy FXML to TornadoFX buidlers, or would like to put that off as long as possible, TornadoFX can at least streamline the processing of FXML.


## How FXML works

As you have seen earlier, the `root` property of a `View` represents the "most parent" `Node`  containing a hierarchy of children Nodes, which makes up the user interface. When you work with FXML, you do not instantiate this root node directly, but instead ask TornadoFX to load it from a corresponding FXML file. By default, TornadoFX will look for a file with the same name as your view with the `.fxml` file ending, in the same package as your `View` class. You can also override the FXML location with a parameter if you want to put all your FXML files in a single folder or arrange them some other way that does not directly correspond to your `View` location.

## A Simple Example

Let's create a basic user interface that presents a `Label` and a `Button`. We will add functionality to this view so that when the `Button` is clicked, the `Label` will update its `text` with the number of times the `Button` has been clicked.

Create a file named `CounterView.fxml` with the following content:

```xml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>
<BorderPane xmlns="http://javafx.com/javafx/null" xmlns:fx="http://javafx.com/fxml/1">
    <padding>
        <Insets top="20" right="20" bottom="20" left="20"/>
    </padding>

    <center>
        <VBox alignment="CENTER" spacing="10">
            <Label text="0">
                <font>
                    <Font size="20"/>
                </font>
            </Label>
            <Button text="Click to increment" />
        </VBox>
    </center>
</BorderPane>
```
>You may notice above you have to `import` the types you use in FXML just like coding in Java or Kotlin. Intellij IDEA should have a plugin to support using ALT+ENTER to generate the `import` statements.

If you load this file in Scene Builder you will see the following result (Figure 9.1). 

**Figure 9.1**

![](http://i.imgur.com/WulUHYa.png)

Next let's make this actually functional and load it into TornadoFX.

### Using the `fxml()` Delegate

We have created an FXML file containing our UI structure. Great! But now we need to load it into a TornadoFX `View` for it to be usable. Logically, we can load this `Node` hierarchy into the `root` node of our `View`. Define the following `View` class. 

```kotlin
class CounterView : View() {
    override val root : BorderPane by fxml()
}
```

Note that the `root` property is defined by the `fxml()` delegate. The `fxml()` delegate takes care of loading the corresponding `CounterView.fxml` into the `root` property.  If we placed `CounterView.fxml` in a different location (such as `/views/`) that is different than where the `CounterView` file resides, we would add a parameter.

```kotlin
class CounterView : View() {
    override val root : BorderPane by fxml("/views/CounterView.fxml")
}
```

the UI, but it has no functionality. We need to define a variable that can represent the number of times the button has been clicked. We add a variable called `counter` and define a function that will increment it's value:

```kotlin
class CounterView : View() {
    override val root : BorderPane by fxml()
    val counter = SimpleIntegerProperty()

    fun increment() {
        counter.value += 1
    }
}
```

We want the `increment()` function to be called whenever the button is clicked. Back in our FXML file, we add the `onAction` attribute to the button:

```xml
<Button text="Click to increment" onAction="#increment"/>
```

Since the FXML file automatically gets bound to our View, we can reference functions via the `#functionName` syntax. Note that we do not add parenthesis to the function call, and you cannot pass parameters directly. You can however add a parameter of type `javafx.event.ActionEvent` to the `increment` function if you want inspect the source Node of the action or check what kind of action triggered the button. For this example we don't need it, so we leave the `increment` function without parameters.

### Access Nodes with the `fxid` delegate

The next thing we want to do is to get a hold of the Label from the FXML file so that we can bind the `counter` value to the `text` property of the Label. We need an identifier for the Label, so in our FXML file we add the `fx:id` attribute to it:

```xml
<Label fx:id="counterLabel">
```

Now we can inject this Label into our View class:

```kotlin
val counterLabel : Label by fxid()
```

This tells TornadoFX to look for a Node with the `fx:id` property set to the same name as the property we defined (counterLabel). It is also possible to use another property name in the View and add a name parameter to the `fxid` delegate:

```kotlin
val myLabel : Label by fxid("counterLabel")
```

Now that we have a hold of the Label, we can use the binding shortcuts of TornadoFX to bind the counter value to the text property of the Label. The whole View now looks like this:

```kotlin
class CounterView : View() {
    override val root : BorderPane by fxml()
    val counter = SimpleIntegerProperty()
    val counterLabel: Label by fxid()

    init {
        counterLabel.bind(counter)
    }

    fun increment() {
        counter.value += 1
    }
}
```

Our app is now complete. Every time the button is clicked, the label will reflect the new number of total clicks.

## Internationalization

JavaFX has strong support for multi language UI's. To support Internationalization in FXML you normally have to register a resource bundle with the FXMLLoader and it will in return replace instances of resource names with their locale-specific value. A resource name is the key in the resource bundle prepended with `%`.

TornadoFX makes this a lot easier by supporting a convention for resource bundles: Create a resource bundle with the same base name as your View, and it will be automatically loaded, both for use programatically within the View and from the FXML file.

Let's internationalize the button label in our UI. Create a file called `CounterView.properties` and add the following content:

```
clickToIncrement=Click to increment
```
> The default resource bundle for our UI

If you want to support multiple languages, create a file with the same base name followed by an underscore, followed by the language code. To support French, create the file `CounterView_fr.properties`. The closest match to the current locale will be used.

Now we simply need to swap the button text with the resource key in the FXML file:

```xml
<Button text="%clickToIncrement" onAction="#increment"/>
```

## A note on Scene Builder

The Scene Builder tool was created by Oracle/Sun but is now [maintained by Gluon](http://gluonhq.com/labs/scene-builder/), an innovative company that invests heavily in JavaFX technology, especially for the mobile market.