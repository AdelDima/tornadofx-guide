#Builders Part III - Type-Safe CSS

While you can create plain text CSS style sheets in JavaFX, TornadoFX provides the option to bring type-safety and compiled CSS to JavaFX. You can conveniently choose to create styles in its own class, or do it inline within a control declaration. 

### Inline CSS

The quickest and easiest way to style a control on the fly is to call a given `Node`'s inline `style { }` function. All the CSS properties available on a given control are available in a type-safe manner, with compilation checks and autocompletion. 

For example, you can style the borders (using the `box()` function) on a `Button`, bold its font, and rotate it (Figure 6.1). 

```kotlin
button("Press Me") {
    style {
        fontWeight = FontWeight.EXTRA_BOLD
        borderColor += box(
                top = Color.RED,
                right = Color.DARKGREEN,
                left = Color.ORANGE,
                bottom = Color.PURPLE
        )
        rotate = 45.deg
    }

    setOnAction { println("You pressed the button") }
}
```

**Figure 6.1**

![](http://i.imgur.com/ELI2VdV.png)

This is especially helpful when you want to style a control without breaking the declaration flow of the `Button`. However, keep in mind the `style { }` will replace all styles applied to that control unless you pass `true` for its optional `append` argument. 


```kotlin
style(append = true) {
      ....
}
```
                    
When you start dealing with more dynamic and conditional stylings, you may want to create a type-safe style sheet which we will cover next. 

### Applying Style Classes with Stylesheets

If you want to organize, re-use, and override styles you need to leverage a `Stylesheet`. Traditionally in JavaFX, a stylesheet is defined in a plain CSS text file included in the project. However, TornadoFX allows creating stylesheets with pure Kotlin code. This has the benefits of compilation checks, auto-completion, and other perks that come with statically typed code.

To declare a `Stylesheet`, extend it onto your own class to hold your customized styles. 

```kotlin
import tornadofx.*

class MyStyle: Stylesheet() {
}
```

Next, you will want to specify its `companion object` to hold class-level properties that can easily be retrieved. Declare a new `cssclass()`-delegated property called `tackyButton`, and define four colors we will use for its borders. 

```kotlin
import javafx.scene.paint.Color
import tornadofx.*

class MyStyle: Stylesheet() {

    companion object {
        val tackyButton by cssclass()

        private val topColor = Color.RED
        private val rightColor = Color.DARKGREEN
        private val leftColor = Color.ORANGE
        private val bottomColor = Color.PURPLE
    }
}
```

Note also you can use the `c()` function to build colors quickly using RGB values or color Strings. 

```kotlin
  private val topColor = c("#FF0000")
  private val rightColor = c("#006400")
  private val leftColor = c("#FFA500)")
  private val bottomColor = c("#800080")
  ```

Finally, declare an `init()` block. Call the `s()` function (which is an alias for the `select()` function) and provide a block that manipulates its various properties. Set `rotate` to 10 degrees, define the `borderColor` using the four colors and the `box()` function, make the font family "Comic Sans MS", and increase the `fontSize` to 20 pixels. Note that there are extension properties for `Number` types to quickly yield the value in that unit, such as `10.deg` for 10 degrees and `20.px` for 20 pixels. 

```kotlin
import javafx.scene.paint.Color
import tornadofx.*

class MyStyle: Stylesheet() {

    companion object {
        val tackyButton by cssclass()

        private val topColor = Color.RED
        private val rightColor = Color.DARKGREEN
        private val leftColor = Color.ORANGE
        private val bottomColor = Color.PURPLE
    }

    init {
        s(tackyButton) {
            rotate = 10.deg
            borderColor += box(topColor,rightColor,leftColor,bottomColor)
            fontFamily = arrayOf("Comic Sans MS")
            fontSize = 20.px
        }
    }
}
```

>s() is a shorthand alias for the `select()` function. Using either is valid and accomplish the same thing.

Now you can apply the `tackyButton` style to buttons, labels, and other controls that support these properties. While this styling can work with other controls like labels, we are going to target buttons specifically. 

But first, load the `MyStyle` stylesheet into your application. 

```kotlin
class MyApp: App() {
    override val primaryView = MyView::class

    init {
        importStylesheet(MyStyle::class)
        reloadStylesheetsOnFocus()
    }
}
```

You can apply styles directly to a control by calling its `addClass()` function. Provide the `MyStyle.tackyButton` style to two buttons (Figure 6.2). 

```kotlin
class MyView: View() {

    override val root = BorderPane()

    init {
        with(root) {
            center {
                button("Press Me") {
                    addClass(MyStyle.tackyButton)
                }
                button("Press Me Too") {
                    addClass(MyStyle.tackyButton)
                }
            }
        }
    }
}
```

**Figure 6.2**

![](http://i.imgur.com/INPUj7s.png)

>Intellij IDEA can perform a quickfix to import member variables, allowing `addClass(MyStyle.tackyButton)` to be shortened to `addClass(tackyButton)` if you prefer. 

You can also target all `Button` instances in your application by selecting and modifying the `button` in the `Stylesheet`. This will apply the style to all Buttons. 

```kotlin
import javafx.scene.paint.Color
import tornadofx.*

class MyStyle: Stylesheet() {

    companion object {

        val tackyButton by cssclass()

        private val topColor = Color.RED
        private val rightColor = Color.DARKGREEN
        private val leftColor = Color.ORANGE
        private val bottomColor = Color.PURPLE

    }
    init {
        s(button) {
            rotate = 10.deg
            borderColor += box(topColor,rightColor,leftColor,bottomColor)
            fontFamily = arrayOf("Comic Sans MS")
            fontSize = 20.px
        }
    }
```

```kotlin
import javafx.scene.layout.VBox
import tornadofx.*

class MyApp: App() {
    override val primaryView = MyView::class

    init {
        importStylesheet(MyStyle::class)
        reloadStylesheetsOnFocus()
    }
}
```

```kotlin
class MyView: View() {

    override val root = VBox()

    init {
        with(root) {
            button("Press Me")
            button("Press Me Too")
        }
    }
}
```

**Figure 6.3**

![](http://i.imgur.com/INPUj7s.png)

###Multi-Value CSS Properties

Some CSS properties accept multiple values, and TornadoFX Stylesheets can streamline this inline with the `multi()` function. This allows you to specify multiple values via a `varargs` parameter and let TornadoFX take care of the rest. For instance, you can nest multiple background colors and insets into a control (Figure 6.4). 

```kotlin
label("Lore Ipsum") {
    style {
        fontSize = 30.px
        backgroundColor = multi(Color.RED, Color.BLUE, Color.YELLOW)
        backgroundInsets = multi(box(4.px), box(8.px), box(12.px))
    }
}
```

**Figure 6.4**

![](http://i.imgur.com/TgtS8nX.png)

The `multi()` function should work wherever multiple values are accepted. If you want to only assign a single value to a property that accepts multiple values, you will need to use the `plusAssign()` operator to add it. 

```kotlin
 label("Lore Ipsum") {
      style {
          fontSize = 30.px
          backgroundColor += Color.RED
          backgroundInsets += box(4.px)
      }
  }
  ```